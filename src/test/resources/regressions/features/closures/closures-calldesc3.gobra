// Any copyright is dedicated to the Public Domain.
// http://creativecommons.org/publicdomain/zero/1.0/

package closuresCallDesc2

// This example shows how it is possible for a higher-order function to express
// that a certain specification is required to hold only once

type Once interface {
    pred inv()

    ghost
    requires inv()
    pure holds()bool

    ghost
    requires inv()
    pure calledWith(x int)bool

    ghost pure res(x int)int
}

requires o != nil && o.inv() && o.holds()
ensures o.inv() && o.calledWith(x) && res == o.res(x)
ensures res == x
func onceId(ghost o Once, x int) (res int)

requires f implements onceId{o}
requires o != nil && o.inv() && o.holds()
ensures o.inv() && o.calledWith(42) && res == 42
func hof(ghost o Once, f func(int)int)(res int) {
    return f(42) as onceId{o}
}

type OnceId struct { accum *int }
pred (self OnceId) inv() { acc(self.accum) }
ghost
requires self.inv()
pure func (self OnceId) holds()bool {
    return unfolding self.inv() in (*self.accum == 0)
}
ghost
requires self.inv()
pure func (self OnceId) calledWith(x int)bool {
    return unfolding self.inv() in (*self.accum == x)
}
ghost pure func (self OnceId) res(x int)int {
    return x
}

func main() {
    accum@ := 0
    cl :=   preserves acc(&accum)
            ensures accum == old(accum) + x
            ensures y == accum
            func accumulate(x int)(y int) {
                accum += x
                return accum
            }
    proof cl implements onceId{OnceId{&accum}} {
        unfold OnceId{&accum}.inv()
        res = cl(x) as accumulate
        fold OnceId{&accum}.inv()
    }

    fold OnceId{&accum}.inv()
    r := hof(OnceId{&accum}, cl)
    assert r == 42

    unfold OnceId{&accum}.inv()
    assert accum == 42
}